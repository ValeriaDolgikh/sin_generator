#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <stdint.h>

#define BITWIDTH        16
#define ERROR_FILE_OPEN -1

int WriteData (const int16_t* data, int size, const char* name_of_file);
int16_t* gen_function (int f, int16_t* data, unsigned N_count, unsigned ADC_freq_numb, unsigned signal_freq_numb);
int16_t* sin_generator (unsigned N_count, unsigned ADC_freq_numb, unsigned signal_freq_numb);
int16_t* cos_generator (unsigned N_count, unsigned ADC_freq_numb, unsigned signal_freq_numb);

typedef  enum
{
	SIN_CODE = 0,
	COS_CODE,
} waveform_code;

int main(int argc, char *argv[])
{
	if (argc == 2)
	{
		if(strcmp(argv[1], "--help") == 0 || strcmp(argv[1], "-h") == 0)
		{
			printf("THIS PROGRAM CREATES A TEXT FILE IN WHICH IT WRITES THE DATA GENERATED BY IT (f.e. sine)\n\n\
a name.txt signal_friq time ADC_freq waveform\n\n\
	a 				a.exe\n\
	name.txt 			the name of file to which the generated data will be written\n\
	signal_friq 			friquency of the signal received at the input (Hz)\n\
	time 				input signal measurement time (sec)\n\
	ADC_freq 			frequency at which rhe ADC measures the input signal(Hz)\n\
	waveform			the waveform we are going to receive (sin/cos/...)\n");			
		}
		else
		{
			printf("%s\n", argv[1]);
			printf("wrong argument\n");
		}
	}
	

	char* name_of_file = argv[1];
	char* signal_freq = argv[2];
	char* time = argv[3];
	char* ADC_freq = argv[4];
	char* waveform = argv[5];

	float signal_freq_numb = atoi(signal_freq);
	float time_numb = atoi(time);
	float ADC_freq_numb = atoi(ADC_freq);

	unsigned N_count = time_numb * ADC_freq_numb;
	
	waveform_code f;
	if(strcmp(waveform, "sin") == 0)
	{
		f = SIN_CODE;
	}
	else if (strcmp(waveform, "cos") == 0)
	{
		f = COS_CODE;
	}
	else
	{
		printf("Error wavefom argument\n");
		return 0;
	}

	int16_t* data = gen_function(f, data, N_count, ADC_freq_numb, signal_freq_numb);

	/*for (unsigned i = 0; i < N_count; i++)
	{
		printf("%d  ", *(data + i));
	}*/
	
	int is_write = WriteData(data, N_count, name_of_file);
	return 0;
}

/*принимает на вход: колическтво отсчётов(размер массива), частоту АЦП, частоту принимаемого сигнала
создаёт динамический массив типа int16_t и записывает в него значения измеренного синусоидального сигнала
возвращает указатель на массив*/
int16_t* sin_generator (unsigned N_count, unsigned ADC_freq_numb, unsigned signal_freq_numb)
{
	int16_t* data = malloc(N_count * sizeof(int16_t));
	unsigned amp = pow(2, BITWIDTH - 1) - 1;
	double rad = signal_freq_numb * (2 * M_PI);

	for (unsigned i = 0; i < N_count; i++)
	{
		double t = (double)i / ADC_freq_numb;
		data[i] = (int16_t)(amp * sin(rad * t));
	}
	return data;
}

int16_t* cos_generator (unsigned N_count, unsigned ADC_freq_numb, unsigned signal_freq_numb)
{
	int16_t* data = malloc(N_count * sizeof(int16_t));
	unsigned amp = pow(2, BITWIDTH - 1) - 1;
	double rad = signal_freq_numb * (2 * M_PI);

	for (unsigned i = 0; i < N_count; i++)
	{
		double t = (double)i / ADC_freq_numb;
		data[i] = (int16_t)(amp * cos(rad * t));
	}
	return data;
}

int16_t* gen_function (int f, int16_t* data, unsigned N_count, unsigned ADC_freq_numb, unsigned signal_freq_numb)
{
	switch(f)
	{
		case SIN_CODE:
		{
			data = sin_generator(N_count, ADC_freq_numb, signal_freq_numb);
			break;
		}
		case COS_CODE:
		{
			data = cos_generator(N_count, ADC_freq_numb, signal_freq_numb);
			break;
		}
		default:
		{
			break;
		}
	}
}

// записывает массив известного размера в файл в бинарном виде
int WriteData (const int16_t* data, int size, const char* name_of_file)
{
	FILE *my_file = NULL;
	my_file = fopen(name_of_file, "wb");
	if (my_file == NULL)
	{
		printf("ERROR_FILE_OPEN\n");
        return ERROR_FILE_OPEN;
    }
   
    int fwrite_res = fwrite(data, sizeof(int16_t), size, my_file);

	fclose(my_file);
	return fwrite_res;
}

//a data.txt 1 1 128 sin